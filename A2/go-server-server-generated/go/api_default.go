/*
 * Album Store API
 *
 * CS6650 Fall 2023
 *
 * API version: 1.0.0
 * Contact: i.gorton@northeasern.edu
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"encoding/json"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"

)

var albumIDCounter int64
var myMap = NewSafeMap()

type SafeMap struct {
    mu    sync.RWMutex
    items map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        items: make(map[string]interface{}),
    }
}

func (m *SafeMap) Set(key string, value interface{}) {
    m.mu.Lock()
    m.items[key] = value
    m.mu.Unlock()
}

func (m *SafeMap) Get(key string) (interface{}, bool) {
    m.mu.RLock()
    value, ok := m.items[key]
    m.mu.RUnlock()
    return value, ok
}

func NewAlbumID() string {
    // Increment the counter and return the new value
    return strconv.FormatInt(atomic.AddInt64(&albumIDCounter, 1), 10)
}

func (m *SafeMap) AddAlbum(albumInfo interface{}) string {
    albumID := NewAlbumID() // Generate a new album ID
    m.Set(albumID, albumInfo)
    return albumID
}

var albumCount = 0
var response struct {
	AlbumID int64 `json:"AlbumID"`
	ImageSize       int64   `json:"imageSize"`
}

func GetAlbumByKey(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	//count the number of parameters in the request
	queryValues := r.URL.Query()
	//if the request does not contain any parameters, return an error
	if len(queryValues) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("No parameters"))
		return
	}
	//if the request contains more than one parameter, return an error
	if len(queryValues) > 1 {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte("More than one parameter"))
		return
	}
	//process the request
	for key, value := range r.URL.Query() {
		//check if the parameter is key
		if strings.Compare(key, "albumID") == 0 {
			//check if the key is valid
			//convert the string to int
			// albumKey, _ := strconv.Atoi(value[0])
			if profile, ok := myMap.Get(value[0]); ok {
				//if the key is valid, return the profile
				w.WriteHeader(http.StatusOK)
				json.NewEncoder(w).Encode(profile)
				return
			} else {
				//if the key is not valid, return an error
				w.WriteHeader(http.StatusNotFound)
				w.Write([]byte("Key not found"))
				return
			}
		} else {
			//if the parameter is not key, return an error
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("Wrong parameter"))
			return
		}
	}
	
}

func NewAlbum(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	//check if we have a body and if the body is of form multipart/form-data
	contentType := r.Header.Get("Content-Type")
	if r.Body == nil || !strings.HasPrefix(contentType, "multipart/form-data"){
		w.Write([]byte("no body or not multipart"))
		w.WriteHeader(http.StatusBadRequest)//return an error
	}else{
		//get the image and measure its size
		file, header, err := r.FormFile("image")
		if err != nil {
			http.Error(w, "Error retrieving the image", http.StatusBadRequest)
			return
		}
		imageSize := header.Size
		defer file.Close()

		//get the profile
		jsonPart := r.FormValue("profile")

		//parse the profile
		var profile AlbumsProfile
		// if err := json.NewDecoder(jsonPart).Decode(&profile); err != nil {
		// 	http.Error(w, "Error decoding the profile", http.StatusBadRequest)
		// 	return
		// }
		if err := json.Unmarshal([]byte(jsonPart), &profile); err != nil {
			http.Error(w, "Error decoding the profile", http.StatusBadRequest)
			return
		}

		// //generate a key for the album and store it in the map
		// albumCount++
		// myMap[albumCount] = profile
		// myMap.Set(strconv.Itoa(albumCount), profile)
		albumID := myMap.AddAlbum(profile)

		// Return the size of the image and the key of the album in JSON format
		w.WriteHeader(http.StatusOK)
		// Prepare the JSON response
		response.ImageSize = imageSize
		response.AlbumID, err = strconv.ParseInt(albumID, 10, 64)
		json.NewEncoder(w).Encode(response)
		return
	}
}



